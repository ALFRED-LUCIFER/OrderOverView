<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LISA Audio Console Diagnostic</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            color: #4a5568;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            background: #f8fafc;
        }
        .test-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px 10px 10px 0;
            transition: all 0.3s ease;
        }
        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        .test-button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }
        .result {
            margin: 10px 0;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .success { background: #f0fff4; border: 1px solid #68d391; color: #22543d; }
        .error { background: #fed7d7; border: 1px solid #fc8181; color: #742a2a; }
        .warning { background: #fefcbf; border: 1px solid #f6e05e; color: #744210; }
        .info { background: #ebf8ff; border: 1px solid #63b3ed; color: #2a4365; }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .status-card {
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            background: white;
        }
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .green { background: #48bb78; }
        .red { background: #f56565; }
        .yellow { background: #ed8936; }
        .console-output {
            background: #1a202c;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
        }
        .clear-btn {
            background: #e53e3e;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîä LISA Audio Console Diagnostic</h1>
        
        <!-- Status Overview -->
        <div class="test-section">
            <h2>üéØ Browser Audio Status</h2>
            <div class="status-grid" id="statusGrid">
                <!-- Status cards will be populated by JavaScript -->
            </div>
        </div>

        <!-- Console Output -->
        <div class="test-section">
            <h2>üñ•Ô∏è Console Output</h2>
            <button class="clear-btn" onclick="clearConsoleOutput()">Clear Console</button>
            <div class="console-output" id="consoleOutput"></div>
        </div>

        <!-- Quick Tests -->
        <div class="test-section">
            <h2>‚ö° Quick Audio Tests</h2>
            <button class="test-button" onclick="runFullDiagnostic()">üîç Run Full Diagnostic</button>
            <button class="test-button" onclick="testBasicSpeech()">üó£Ô∏è Test Basic Speech</button>
            <button class="test-button" onclick="testChromeAutoplay()">üéµ Test Chrome Autoplay</button>
            <button class="test-button" onclick="testUserGesture()">üëÜ Test User Gesture</button>
            <button class="test-button" onclick="testLISAWorkflow()">ü§ñ Test LISA Workflow</button>
        </div>

        <!-- Advanced Tests -->
        <div class="test-section">
            <h2>üî¨ Advanced Diagnostics</h2>
            <button class="test-button" onclick="checkSpeechSynthesis()">üì¢ Check SpeechSynthesis API</button>
            <button class="test-button" onclick="checkVoices()">üé§ Check Available Voices</button>
            <button class="test-button" onclick="checkMediaDevices()">üéß Check Media Devices</button>
            <button class="test-button" onclick="checkPermissions()">üîê Check Permissions</button>
            <button class="test-button" onclick="checkWebSocket()">üîå Test WebSocket</button>
        </div>

        <!-- Environment Info -->
        <div class="test-section">
            <h2>üåê Environment Information</h2>
            <div id="environmentInfo" class="result info"></div>
        </div>

        <!-- Test Results -->
        <div class="test-section">
            <h2>üìä Test Results</h2>
            <div id="testResults"></div>
        </div>
    </div>

    <script>
        // Console output capture
        let consoleOutput = document.getElementById('consoleOutput');
        
        // Override console methods to capture output
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;
        
        function logToConsole(message, type = 'log') {
            const timestamp = new Date().toLocaleTimeString();
            const colorClass = type === 'error' ? 'color: #fc8181' : 
                              type === 'warn' ? 'color: #f6e05e' : 'color: #68d391';
            
            consoleOutput.innerHTML += `<div style="${colorClass}">
                [${timestamp}] ${type.toUpperCase()}: ${message}
            </div>`;
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
        }
        
        console.log = function(...args) {
            originalLog.apply(console, args);
            logToConsole(args.join(' '), 'log');
        };
        
        console.error = function(...args) {
            originalError.apply(console, args);
            logToConsole(args.join(' '), 'error');
        };
        
        console.warn = function(...args) {
            originalWarn.apply(console, args);
            logToConsole(args.join(' '), 'warn');
        };

        function clearConsoleOutput() {
            consoleOutput.innerHTML = '';
        }

        // Audio diagnostic functions
        function updateStatus(statusId, status, message) {
            const statusGrid = document.getElementById('statusGrid');
            const existingCard = document.getElementById(statusId);
            
            const colorClass = status === 'success' ? 'green' : 
                              status === 'error' ? 'red' : 'yellow';
            
            const cardHTML = `
                <div class="status-card" id="${statusId}">
                    <span class="status-indicator ${colorClass}"></span>
                    <strong>${statusId.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}</strong>
                    <div style="margin-top: 5px; font-size: 0.9em;">${message}</div>
                </div>
            `;
            
            if (existingCard) {
                existingCard.outerHTML = cardHTML;
            } else {
                statusGrid.innerHTML += cardHTML;
            }
        }

        function addResult(message, type = 'info') {
            const results = document.getElementById('testResults');
            const div = document.createElement('div');
            div.className = `result ${type}`;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            results.appendChild(div);
            results.scrollTop = results.scrollHeight;
        }

        // Environment detection
        function detectEnvironment() {
            const info = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language,
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine,
                protocol: location.protocol,
                hostname: location.hostname,
                port: location.port,
                isSecure: location.protocol === 'https:',
                isLocalhost: location.hostname === 'localhost' || location.hostname === '127.0.0.1',
                browser: getBrowserInfo(),
                speechSynthesisSupported: 'speechSynthesis' in window,
                webSocketSupported: 'WebSocket' in window,
                mediaDevicesSupported: 'mediaDevices' in navigator
            };
            
            document.getElementById('environmentInfo').textContent = JSON.stringify(info, null, 2);
            console.log('üåê Environment Info:', info);
            return info;
        }

        function getBrowserInfo() {
            const ua = navigator.userAgent;
            if (ua.includes('Chrome')) return 'Chrome';
            if (ua.includes('Firefox')) return 'Firefox';
            if (ua.includes('Safari')) return 'Safari';
            if (ua.includes('Edge')) return 'Edge';
            return 'Unknown';
        }

        // Basic speech test
        async function testBasicSpeech() {
            console.log('üó£Ô∏è Testing basic speech synthesis...');
            addResult('Testing basic speech synthesis...', 'info');
            
            try {
                if (!('speechSynthesis' in window)) {
                    throw new Error('SpeechSynthesis not supported');
                }
                
                const utterance = new SpeechSynthesisUtterance('Hello, this is a basic speech test');
                utterance.rate = 1.0;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                
                let speechStarted = false;
                let speechEnded = false;
                
                utterance.onstart = () => {
                    speechStarted = true;
                    console.log('‚úÖ Speech started successfully');
                    addResult('Speech started successfully', 'success');
                    updateStatus('basicSpeech', 'success', 'Speech synthesis working');
                };
                
                utterance.onend = () => {
                    speechEnded = true;
                    console.log('‚úÖ Speech ended successfully');
                    addResult('Speech ended successfully', 'success');
                };
                
                utterance.onerror = (event) => {
                    console.error('‚ùå Speech error:', event.error);
                    addResult(`Speech error: ${event.error}`, 'error');
                    updateStatus('basicSpeech', 'error', `Error: ${event.error}`);
                };
                
                speechSynthesis.speak(utterance);
                
                // Timeout check
                setTimeout(() => {
                    if (!speechStarted) {
                        console.warn('‚ö†Ô∏è Speech did not start within 3 seconds');
                        addResult('Speech timeout - did not start', 'warning');
                        updateStatus('basicSpeech', 'error', 'Speech timeout');
                    }
                }, 3000);
                
            } catch (error) {
                console.error('‚ùå Basic speech test failed:', error.message);
                addResult(`Basic speech test failed: ${error.message}`, 'error');
                updateStatus('basicSpeech', 'error', error.message);
            }
        }

        // Chrome autoplay test
        async function testChromeAutoplay() {
            console.log('üéµ Testing Chrome autoplay policy...');
            addResult('Testing Chrome autoplay policy...', 'info');
            
            try {
                // Test audio context
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                if (audioContext.state === 'suspended') {
                    console.warn('‚ö†Ô∏è AudioContext is suspended (autoplay blocked)');
                    addResult('AudioContext suspended - autoplay blocked', 'warning');
                    updateStatus('autoplayPolicy', 'warning', 'AudioContext suspended');
                    
                    // Try to resume
                    try {
                        await audioContext.resume();
                        console.log('‚úÖ AudioContext resumed successfully');
                        addResult('AudioContext resumed after user gesture', 'success');
                        updateStatus('autoplayPolicy', 'success', 'AudioContext resumed');
                    } catch (resumeError) {
                        console.error('‚ùå Failed to resume AudioContext:', resumeError);
                        addResult(`Failed to resume AudioContext: ${resumeError.message}`, 'error');
                        updateStatus('autoplayPolicy', 'error', 'Cannot resume AudioContext');
                    }
                } else {
                    console.log('‚úÖ AudioContext is running');
                    addResult('AudioContext is running', 'success');
                    updateStatus('autoplayPolicy', 'success', 'AudioContext running');
                }
                
                audioContext.close();
                
            } catch (error) {
                console.error('‚ùå Autoplay test failed:', error.message);
                addResult(`Autoplay test failed: ${error.message}`, 'error');
                updateStatus('autoplayPolicy', 'error', error.message);
            }
        }

        // User gesture test
        function testUserGesture() {
            console.log('üëÜ Testing speech with user gesture...');
            addResult('Testing speech with user gesture...', 'info');
            
            // This function is called by user click, so it has user gesture
            if (!('speechSynthesis' in window)) {
                console.error('‚ùå SpeechSynthesis not supported');
                addResult('SpeechSynthesis not supported', 'error');
                updateStatus('userGesture', 'error', 'SpeechSynthesis not supported');
                return;
            }
            
            const utterance = new SpeechSynthesisUtterance('This speech test has user gesture');
            utterance.rate = 1.0;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;
            
            utterance.onstart = () => {
                console.log('‚úÖ User gesture speech started');
                addResult('User gesture speech started', 'success');
                updateStatus('userGesture', 'success', 'Speech with user gesture works');
            };
            
            utterance.onerror = (event) => {
                console.error('‚ùå User gesture speech error:', event.error);
                addResult(`User gesture speech error: ${event.error}`, 'error');
                updateStatus('userGesture', 'error', `Error: ${event.error}`);
            };
            
            speechSynthesis.speak(utterance);
        }

        // Check SpeechSynthesis API
        function checkSpeechSynthesis() {
            console.log('üì¢ Checking SpeechSynthesis API...');
            addResult('Checking SpeechSynthesis API...', 'info');
            
            const checks = {
                supported: 'speechSynthesis' in window,
                speaking: window.speechSynthesis ? speechSynthesis.speaking : false,
                pending: window.speechSynthesis ? speechSynthesis.pending : false,
                paused: window.speechSynthesis ? speechSynthesis.paused : false
            };
            
            console.log('üì¢ SpeechSynthesis status:', checks);
            addResult(`SpeechSynthesis status: ${JSON.stringify(checks, null, 2)}`, 'info');
            
            if (checks.supported) {
                updateStatus('speechSynthesis', 'success', 'SpeechSynthesis API available');
            } else {
                updateStatus('speechSynthesis', 'error', 'SpeechSynthesis API not supported');
            }
        }

        // Check available voices
        function checkVoices() {
            console.log('üé§ Checking available voices...');
            addResult('Checking available voices...', 'info');
            
            if (!('speechSynthesis' in window)) {
                console.error('‚ùå SpeechSynthesis not supported');
                addResult('SpeechSynthesis not supported', 'error');
                updateStatus('voices', 'error', 'SpeechSynthesis not supported');
                return;
            }
            
            const voices = speechSynthesis.getVoices();
            
            if (voices.length === 0) {
                console.warn('‚ö†Ô∏è No voices available yet, waiting...');
                addResult('No voices available yet, waiting...', 'warning');
                
                speechSynthesis.onvoiceschanged = () => {
                    const newVoices = speechSynthesis.getVoices();
                    console.log(`üé§ Found ${newVoices.length} voices:`, newVoices.map(v => `${v.name} (${v.lang})`));
                    addResult(`Found ${newVoices.length} voices`, 'success');
                    updateStatus('voices', 'success', `${newVoices.length} voices available`);
                };
            } else {
                console.log(`üé§ Found ${voices.length} voices:`, voices.map(v => `${v.name} (${v.lang})`));
                addResult(`Found ${voices.length} voices`, 'success');
                updateStatus('voices', 'success', `${voices.length} voices available`);
            }
        }

        // Check media devices
        async function checkMediaDevices() {
            console.log('üéß Checking media devices...');
            addResult('Checking media devices...', 'info');
            
            if (!('mediaDevices' in navigator)) {
                console.error('‚ùå MediaDevices not supported');
                addResult('MediaDevices not supported', 'error');
                updateStatus('mediaDevices', 'error', 'MediaDevices not supported');
                return;
            }
            
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioOutputs = devices.filter(device => device.kind === 'audiooutput');
                const audioInputs = devices.filter(device => device.kind === 'audioinput');
                
                console.log(`üéß Audio outputs: ${audioOutputs.length}, Audio inputs: ${audioInputs.length}`);
                addResult(`Audio outputs: ${audioOutputs.length}, Audio inputs: ${audioInputs.length}`, 'success');
                updateStatus('mediaDevices', 'success', `${audioOutputs.length} outputs, ${audioInputs.length} inputs`);
                
            } catch (error) {
                console.error('‚ùå Media devices check failed:', error.message);
                addResult(`Media devices check failed: ${error.message}`, 'error');
                updateStatus('mediaDevices', 'error', error.message);
            }
        }

        // Check permissions
        async function checkPermissions() {
            console.log('üîê Checking permissions...');
            addResult('Checking permissions...', 'info');
            
            const permissions = ['microphone', 'speaker-selection'];
            const results = {};
            
            for (const permission of permissions) {
                try {
                    if ('permissions' in navigator && 'query' in navigator.permissions) {
                        const result = await navigator.permissions.query({ name: permission });
                        results[permission] = result.state;
                        console.log(`üîê ${permission}: ${result.state}`);
                    } else {
                        results[permission] = 'not_supported';
                        console.warn(`‚ö†Ô∏è ${permission}: permission API not supported`);
                    }
                } catch (error) {
                    results[permission] = 'error';
                    console.error(`‚ùå ${permission}: ${error.message}`);
                }
            }
            
            addResult(`Permissions: ${JSON.stringify(results, null, 2)}`, 'info');
            
            const hasErrors = Object.values(results).some(state => state === 'denied' || state === 'error');
            updateStatus('permissions', hasErrors ? 'warning' : 'success', JSON.stringify(results));
        }

        // Test WebSocket connection
        function checkWebSocket() {
            console.log('üîå Testing WebSocket connection...');
            addResult('Testing WebSocket connection...', 'info');
            
            if (!('WebSocket' in window)) {
                console.error('‚ùå WebSocket not supported');
                addResult('WebSocket not supported', 'error');
                updateStatus('websocket', 'error', 'WebSocket not supported');
                return;
            }
            
            // Test connection to backend
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${location.hostname}:3001/voice`;
            
            console.log(`üîå Connecting to: ${wsUrl}`);
            addResult(`Connecting to: ${wsUrl}`, 'info');
            
            const ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                console.log('‚úÖ WebSocket connected successfully');
                addResult('WebSocket connected successfully', 'success');
                updateStatus('websocket', 'success', 'WebSocket connection works');
                ws.close();
            };
            
            ws.onerror = (error) => {
                console.error('‚ùå WebSocket connection failed:', error);
                addResult('WebSocket connection failed', 'error');
                updateStatus('websocket', 'error', 'WebSocket connection failed');
            };
            
            ws.onclose = (event) => {
                if (event.code !== 1000) { // Not normal closure
                    console.warn(`‚ö†Ô∏è WebSocket closed unexpectedly: ${event.code} - ${event.reason}`);
                    addResult(`WebSocket closed: ${event.code} - ${event.reason}`, 'warning');
                    updateStatus('websocket', 'warning', `Closed: ${event.code}`);
                }
            };
            
            // Timeout
            setTimeout(() => {
                if (ws.readyState === WebSocket.CONNECTING) {
                    console.warn('‚ö†Ô∏è WebSocket connection timeout');
                    addResult('WebSocket connection timeout', 'warning');
                    updateStatus('websocket', 'error', 'Connection timeout');
                    ws.close();
                }
            }, 5000);
        }

        // Test LISA workflow
        function testLISAWorkflow() {
            console.log('ü§ñ Testing LISA workflow simulation...');
            addResult('Testing LISA workflow simulation...', 'info');
            
            // Simulate LISA's audio workflow
            const steps = [
                { name: 'Check SpeechSynthesis', test: () => 'speechSynthesis' in window },
                { name: 'Check Voices', test: () => speechSynthesis.getVoices().length > 0 },
                { name: 'Create Utterance', test: () => {
                    try {
                        new SpeechSynthesisUtterance('test');
                        return true;
                    } catch (e) {
                        return false;
                    }
                }},
                { name: 'Test Speech', test: () => {
                    return new Promise((resolve) => {
                        const utterance = new SpeechSynthesisUtterance('LISA workflow test');
                        utterance.onstart = () => resolve(true);
                        utterance.onerror = () => resolve(false);
                        speechSynthesis.speak(utterance);
                        setTimeout(() => resolve(false), 3000);
                    });
                }}
            ];
            
            let allPassed = true;
            
            for (const step of steps) {
                try {
                    const result = step.test();
                    if (result instanceof Promise) {
                        result.then(passed => {
                            if (passed) {
                                console.log(`‚úÖ LISA Step: ${step.name} - PASSED`);
                                addResult(`LISA Step: ${step.name} - PASSED`, 'success');
                            } else {
                                console.error(`‚ùå LISA Step: ${step.name} - FAILED`);
                                addResult(`LISA Step: ${step.name} - FAILED`, 'error');
                                allPassed = false;
                            }
                        });
                    } else if (result) {
                        console.log(`‚úÖ LISA Step: ${step.name} - PASSED`);
                        addResult(`LISA Step: ${step.name} - PASSED`, 'success');
                    } else {
                        console.error(`‚ùå LISA Step: ${step.name} - FAILED`);
                        addResult(`LISA Step: ${step.name} - FAILED`, 'error');
                        allPassed = false;
                    }
                } catch (error) {
                    console.error(`‚ùå LISA Step: ${step.name} - ERROR: ${error.message}`);
                    addResult(`LISA Step: ${step.name} - ERROR: ${error.message}`, 'error');
                    allPassed = false;
                }
            }
            
            setTimeout(() => {
                updateStatus('lisaWorkflow', allPassed ? 'success' : 'error', 
                    allPassed ? 'LISA workflow checks passed' : 'LISA workflow has issues');
            }, 1000);
        }

        // Full diagnostic
        async function runFullDiagnostic() {
            console.log('üîç Running full audio diagnostic...');
            addResult('Starting full audio diagnostic...', 'info');
            
            // Clear previous results
            document.getElementById('statusGrid').innerHTML = '';
            
            // Run all tests
            detectEnvironment();
            checkSpeechSynthesis();
            checkVoices();
            await checkMediaDevices();
            await checkPermissions();
            checkWebSocket();
            await new Promise(resolve => setTimeout(resolve, 1000)); // Wait a bit
            testChromeAutoplay();
            testLISAWorkflow();
            
            console.log('üîç Full diagnostic completed');
            addResult('Full diagnostic completed', 'success');
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            console.log('üöÄ LISA Audio Console Diagnostic initialized');
            detectEnvironment();
            
            // Auto-run basic checks
            setTimeout(() => {
                checkSpeechSynthesis();
                checkVoices();
            }, 1000);
        });

        // Add console commands for easy testing
        window.LISAAudioDiagnostic = {
            runFullDiagnostic,
            testBasicSpeech,
            testChromeAutoplay,
            testUserGesture,
            checkSpeechSynthesis,
            checkVoices,
            checkMediaDevices,
            checkPermissions,
            checkWebSocket,
            testLISAWorkflow,
            clearConsole: clearConsoleOutput
        };

        console.log('üí° Available console commands:');
        console.log('   LISAAudioDiagnostic.runFullDiagnostic()');
        console.log('   LISAAudioDiagnostic.testBasicSpeech()');
        console.log('   LISAAudioDiagnostic.testUserGesture()');
        console.log('   LISAAudioDiagnostic.clearConsole()');
    </script>
</body>
</html>
