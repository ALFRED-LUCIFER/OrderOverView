<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speech Timeout Fix Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background: #45a049;
        }
        button.danger {
            background: #f44336;
        }
        button.danger:hover {
            background: #da190b;
        }
        .status {
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.warning { background: #fff3cd; color: #856404; }
        .status.info { background: #d1ecf1; color: #0c5460; }
        .debug-info {
            background: #f8f9fa;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            border-left: 4px solid #007bff;
            font-family: monospace;
            white-space: pre-wrap;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé§ Speech Timeout Fix Test</h1>
        <p>Testing the improved speech synthesis with shorter timeouts and auto-recovery mechanisms.</p>
        
        <div id="status" class="status info">
            Ready to test - Click a button to start
        </div>
        
        <div>
            <h3>Basic Tests</h3>
            <button onclick="testQuickSpeech()">‚ö° Quick Speech (2 words)</button>
            <button onclick="testMediumSpeech()">üì¢ Medium Speech (10 words)</button>
            <button onclick="testLongSpeech()">üìñ Long Speech (50 words)</button>
        </div>
        
        <div>
            <h3>Recovery Tests</h3>
            <button onclick="testRepeatedSpeech()">üîÑ Repeated Speech (5x)</button>
            <button onclick="testQueuedSpeech()">üìù Queued Speech (3 items)</button>
            <button onclick="forceReset()" class="danger">üö® Force Reset</button>
        </div>
        
        <div>
            <h3>Monitor</h3>
            <button onclick="showState()">üîç Show Speech State</button>
            <button onclick="clearLog()">üßπ Clear Log</button>
        </div>
        
        <div id="debug-info" class="debug-info"></div>
    </div>

    <script>
        let testCount = 0;
        let currentTest = null;
        
        // Mock AudioService with the new timeout logic
        class TestAudioService {
            constructor() {
                this.speechSynthesis = window.speechSynthesis;
                this.isSpeaking = false;
                this.speechTimeout = null;
                this.speechStartTime = 0;
                this.speechQueue = [];
                this.currentUtterance = null;
                this.voicesLoaded = false;
                this.availableVoices = [];
                this.preferredVoice = null;
                
                // Load voices
                this.loadVoices();
            }
            
            loadVoices() {
                const voices = this.speechSynthesis.getVoices();
                if (voices.length > 0) {
                    this.availableVoices = voices;
                    this.voicesLoaded = true;
                    this.preferredVoice = voices.find(v => v.lang.startsWith('en')) || voices[0];
                    this.log(`‚úÖ Loaded ${voices.length} voices`);
                }
            }
            
            async speak(text, options = {}) {
                return new Promise((resolve, reject) => {
                    this.log(`üó£Ô∏è Speaking: "${text}"`);
                    
                    // Auto-recovery check
                    if (this.autoRecoverIfStuck()) {
                        this.log('üîÑ Recovered from stuck state');
                    }
                    
                    if (this.isSpeaking) {
                        this.log('üìù Adding to queue');
                        this.speechQueue.push({ text, options, resolve, reject });
                        return;
                    }
                    
                    this.performSpeech(text, options, resolve, reject);
                });
            }
            
            autoRecoverIfStuck() {
                if (!this.isSpeaking) return false;
                
                const timeSinceStart = Date.now() - this.speechStartTime;
                const isActuallySpeaking = this.speechSynthesis?.speaking || false;
                
                if (!isActuallySpeaking && timeSinceStart > 2000) {
                    this.log('üö® Detected stuck speech state, auto-recovering...');
                    this.resetSpeechState();
                    return true;
                }
                return false;
            }
            
            performSpeech(text, options, resolve, reject) {
                this.isSpeaking = true;
                this.speechStartTime = Date.now();
                
                const utterance = new SpeechSynthesisUtterance(text);
                if (this.preferredVoice) {
                    utterance.voice = this.preferredVoice;
                }
                
                utterance.rate = options.rate ?? 1.0;
                utterance.pitch = options.pitch ?? 1.0;
                utterance.volume = options.volume ?? 1.0;
                
                // New timeout logic - shorter and smarter
                const wordsCount = text.split(' ').length;
                const estimatedDuration = Math.max(2000, (wordsCount * 600) / utterance.rate);
                const timeoutDuration = Math.min(estimatedDuration + 3000, 15000); // Max 15 seconds
                
                this.log(`‚è±Ô∏è Setting timeout: ${timeoutDuration}ms for ${wordsCount} words`);
                
                this.speechTimeout = setTimeout(() => {
                    this.log('‚ö†Ô∏è Speech timeout triggered');
                    
                    if (this.speechSynthesis?.speaking) {
                        this.log('üîÑ Speech still active, extending timeout...');
                        this.speechTimeout = setTimeout(() => {
                            this.forceReset();
                            reject(new Error('Speech timeout - extended'));
                            this.processQueue();
                        }, 10000);
                    } else {
                        this.log('üö® Speech never started, resetting');
                        this.forceReset();
                        reject(new Error('Speech failed to start'));
                        this.processQueue();
                    }
                }, timeoutDuration);
                
                let callbackFired = false;
                
                utterance.onend = () => {
                    if (callbackFired) return;
                    callbackFired = true;
                    
                    const duration = Date.now() - this.speechStartTime;
                    this.log(`‚úÖ Speech completed in ${duration}ms`);
                    this.clearTimeout();
                    this.isSpeaking = false;
                    this.currentUtterance = null;
                    resolve();
                    this.processQueue();
                };
                
                utterance.onerror = (event) => {
                    if (callbackFired) return;
                    callbackFired = true;
                    
                    this.log(`‚ùå Speech error: ${event.error}`);
                    this.clearTimeout();
                    this.isSpeaking = false;
                    this.currentUtterance = null;
                    
                    if (event.error === 'canceled' || event.error === 'interrupted') {
                        resolve();
                    } else {
                        reject(new Error(`Speech error: ${event.error}`));
                    }
                    this.processQueue();
                };
                
                utterance.onstart = () => {
                    this.log('üé§ Speech started');
                };
                
                this.currentUtterance = utterance;
                this.speechSynthesis.speak(utterance);
                
                // Monitor speech state
                let checkAttempts = 0;
                const monitorSpeech = () => {
                    checkAttempts++;
                    
                    if (callbackFired) return;
                    
                    if (checkAttempts >= 30) { // 3 seconds
                        if (!this.speechSynthesis.speaking && !this.speechSynthesis.pending) {
                            this.log('‚ö†Ô∏è Speech appears stuck - forcing completion');
                            if (!callbackFired) {
                                callbackFired = true;
                                this.clearTimeout();
                                this.isSpeaking = false;
                                this.currentUtterance = null;
                                resolve();
                                this.processQueue();
                            }
                        }
                        return;
                    }
                    
                    setTimeout(monitorSpeech, 100);
                };
                
                setTimeout(monitorSpeech, 200);
            }
            
            clearTimeout() {
                if (this.speechTimeout) {
                    clearTimeout(this.speechTimeout);
                    this.speechTimeout = null;
                }
            }
            
            forceReset() {
                this.log('üö® Force resetting speech state');
                this.clearTimeout();
                this.isSpeaking = false;
                this.currentUtterance = null;
                if (this.speechSynthesis) {
                    this.speechSynthesis.cancel();
                }
            }
            
            resetSpeechState() {
                this.log('üîÑ Resetting speech state');
                this.forceReset();
                this.speechQueue = [];
            }
            
            processQueue() {
                if (this.speechQueue.length === 0 || this.isSpeaking) return;
                
                const { text, options, resolve, reject } = this.speechQueue.shift();
                setTimeout(() => {
                    this.performSpeech(text, options, resolve, reject);
                }, 50);
            }
            
            getState() {
                return {
                    isSpeaking: this.isSpeaking,
                    queueLength: this.speechQueue.length,
                    speechSynthesisSpeaking: this.speechSynthesis?.speaking,
                    speechSynthesisPending: this.speechSynthesis?.pending,
                    speechSynthesisPaused: this.speechSynthesis?.paused,
                    voicesLoaded: this.voicesLoaded,
                    voicesCount: this.availableVoices.length,
                    currentVoice: this.preferredVoice?.name
                };
            }
            
            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                console.log(message);
                const debugDiv = document.getElementById('debug-info');
                debugDiv.textContent += `[${timestamp}] ${message}\n`;
                debugDiv.scrollTop = debugDiv.scrollHeight;
            }
        }
        
        const audioService = new TestAudioService();
        
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
        }
        
        async function testQuickSpeech() {
            currentTest = ++testCount;
            showStatus(`Running test ${currentTest}: Quick Speech`, 'info');
            try {
                await audioService.speak('Hello world');
                showStatus(`Test ${currentTest}: Quick speech completed`, 'success');
            } catch (error) {
                showStatus(`Test ${currentTest}: Quick speech failed - ${error.message}`, 'error');
            }
        }
        
        async function testMediumSpeech() {
            currentTest = ++testCount;
            showStatus(`Running test ${currentTest}: Medium Speech`, 'info');
            try {
                await audioService.speak('This is a medium length test message with about ten words total.');
                showStatus(`Test ${currentTest}: Medium speech completed`, 'success');
            } catch (error) {
                showStatus(`Test ${currentTest}: Medium speech failed - ${error.message}`, 'error');
            }
        }
        
        async function testLongSpeech() {
            currentTest = ++testCount;
            showStatus(`Running test ${currentTest}: Long Speech`, 'info');
            try {
                const longText = 'This is a much longer test message that contains approximately fifty words and should take a reasonable amount of time to speak. The new timeout system should handle this appropriately without triggering false timeouts while still protecting against truly stuck speech synthesis calls that never complete properly.';
                await audioService.speak(longText);
                showStatus(`Test ${currentTest}: Long speech completed`, 'success');
            } catch (error) {
                showStatus(`Test ${currentTest}: Long speech failed - ${error.message}`, 'error');
            }
        }
        
        async function testRepeatedSpeech() {
            currentTest = ++testCount;
            showStatus(`Running test ${currentTest}: Repeated Speech`, 'info');
            try {
                for (let i = 1; i <= 5; i++) {
                    await audioService.speak(`This is speech number ${i} of 5`);
                    await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
                }
                showStatus(`Test ${currentTest}: All 5 speeches completed`, 'success');
            } catch (error) {
                showStatus(`Test ${currentTest}: Repeated speech failed - ${error.message}`, 'error');
            }
        }
        
        async function testQueuedSpeech() {
            currentTest = ++testCount;
            showStatus(`Running test ${currentTest}: Queued Speech`, 'info');
            try {
                // Start all three at once - they should queue
                const promises = [
                    audioService.speak('First queued message'),
                    audioService.speak('Second queued message'),
                    audioService.speak('Third queued message')
                ];
                
                await Promise.all(promises);
                showStatus(`Test ${currentTest}: All queued speeches completed`, 'success');
            } catch (error) {
                showStatus(`Test ${currentTest}: Queued speech failed - ${error.message}`, 'error');
            }
        }
        
        function forceReset() {
            audioService.resetSpeechState();
            showStatus('Speech state force reset', 'warning');
        }
        
        function showState() {
            const state = audioService.getState();
            audioService.log('üîç Current state: ' + JSON.stringify(state, null, 2));
        }
        
        function clearLog() {
            document.getElementById('debug-info').textContent = '';
        }
        
        // Initialize
        window.addEventListener('load', () => {
            setTimeout(() => {
                audioService.loadVoices();
                showState();
            }, 500);
        });
        
        // Load voices when they become available
        if (window.speechSynthesis) {
            window.speechSynthesis.addEventListener('voiceschanged', () => {
                audioService.loadVoices();
            });
        }
    </script>
</body>
</html>
