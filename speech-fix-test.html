<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speech Fix Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background: #45a049;
        }
        button.danger {
            background: #f44336;
        }
        button.danger:hover {
            background: #da190b;
        }
        .debug-info {
            background: #f9f9f9;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            border-left: 4px solid #2196F3;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.warning { background: #fff3cd; color: #856404; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé§ Speech Fix Test</h1>
        <p>This page tests the AudioService speech fixes, particularly the timeout mechanism to prevent stuck isSpeaking state.</p>
        
        <div id="status" class="status"></div>
        
        <div>
            <button onclick="initializeAudio()">üîÑ Initialize Audio</button>
            <button onclick="forceResetSpeech()" class="danger">üö® Force Reset Speech</button>
            <button onclick="testShortSpeech()">üó£Ô∏è Test Short Speech</button>
            <button onclick="testLongSpeech()">üì¢ Test Long Speech</button>
            <button onclick="testStopSpeech()" class="danger">‚èπÔ∏è Stop Speech</button>
        </div>
        
        <div>
            <button onclick="showDebugInfo()">üîç Show Debug Info</button>
            <button onclick="clearLog()">üßπ Clear Log</button>
        </div>
        
        <div id="debug-info" class="debug-info"></div>
        <div id="log" class="debug-info"></div>
    </div>

    <script>
        // Simulate the AudioService for testing
        class TestAudioService {
            constructor() {
                this.speechSynthesis = window.speechSynthesis;
                this.isInitialized = false;
                this.userInteracted = false;
                this.voicesLoaded = false;
                this.availableVoices = [];
                this.preferredVoice = null;
                this.currentUtterance = null;
                this.speechQueue = [];
                this.isSpeaking = false;
                this.speechTimeout = null;
                this.speechStartTime = 0;
                
                this.setupVoiceLoadingHandler();
            }
            
            setupVoiceLoadingHandler() {
                if (!this.speechSynthesis) {
                    this.log('‚ö†Ô∏è speechSynthesis not available');
                    return;
                }
                
                const loadVoices = () => {
                    if (!this.speechSynthesis) return;
                    this.availableVoices = this.speechSynthesis.getVoices();
                    if (this.availableVoices.length > 0) {
                        this.voicesLoaded = true;
                        this.log(`‚úÖ Loaded ${this.availableVoices.length} voices`);
                        this.selectPreferredVoice();
                    }
                };
                
                loadVoices();
                this.speechSynthesis.addEventListener('voiceschanged', loadVoices);
            }
            
            selectPreferredVoice() {
                if (!this.voicesLoaded || this.availableVoices.length === 0) return;
                
                // Find a good voice
                const englishVoices = this.availableVoices.filter(voice => voice.lang.startsWith('en'));
                this.preferredVoice = englishVoices[0] || this.availableVoices[0];
                
                if (this.preferredVoice) {
                    this.log(`üé≠ Selected voice: ${this.preferredVoice.name}`);
                }
            }
            
            async initialize() {
                this.log('üé§ Initializing AudioService...');
                this.userInteracted = true;
                this.isInitialized = true;
                this.log('‚úÖ AudioService initialized');
            }
            
            async speak(text, options = {}) {
                this.log(`üó£Ô∏è Speaking: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`);
                this.log(`üîç Speech state - isSpeaking: ${this.isSpeaking}, queueLength: ${this.speechQueue.length}`);
                
                return new Promise((resolve, reject) => {
                    if (!this.speechSynthesis) {
                        this.log('‚ùå speechSynthesis not available');
                        reject(new Error('speechSynthesis not available'));
                        return;
                    }
                    
                    if (this.isSpeaking) {
                        this.log('üõë Stopping current speech to start new one...');
                        this.stopSpeaking();
                    }
                    
                    if (this.isSpeaking) {
                        this.log('üìù Adding to speech queue...');
                        this.speechQueue.push({ text, options, resolve, reject });
                        return;
                    }
                    
                    this.performSpeech(text, options, resolve, reject);
                });
            }
            
            performSpeech(text, options = {}, resolve, reject) {
                try {
                    this.log('üé§ Starting speech synthesis...');
                    this.isSpeaking = true;
                    this.speechStartTime = Date.now();
                    
                    const utterance = new SpeechSynthesisUtterance(text);
                    
                    if (this.preferredVoice) {
                        utterance.voice = this.preferredVoice;
                        this.log(`üé≠ Using voice: ${this.preferredVoice.name}`);
                    }
                    
                    utterance.rate = options.rate || 0.9;
                    utterance.pitch = options.pitch || 1.0;
                    utterance.volume = options.volume || 0.8;
                    utterance.lang = options.lang || 'en-US';
                    
                    // Set up timeout
                    const estimatedDuration = Math.max(3000, (text.length / 10) * 1000 / utterance.rate);
                    const timeoutDuration = Math.min(estimatedDuration + 5000, 30000);
                    
                    this.log(`‚è±Ô∏è Setting speech timeout: ${timeoutDuration}ms for text length: ${text.length}`);
                    
                    this.speechTimeout = setTimeout(() => {
                        this.log('‚ö†Ô∏è Speech timeout - forcing reset');
                        this.forceSpeechReset();
                        reject(new Error('Speech timeout'));
                    }, timeoutDuration);
                    
                    let callbackFired = false;
                    
                    utterance.onend = () => {
                        if (callbackFired) return;
                        callbackFired = true;
                        this.log('‚úÖ Speech completed');
                        this.clearSpeechTimeout();
                        this.isSpeaking = false;
                        this.currentUtterance = null;
                        resolve();
                        this.processQueue();
                    };
                    
                    utterance.onerror = (event) => {
                        if (callbackFired) return;
                        callbackFired = true;
                        this.log(`‚ùå Speech error: ${event.error}`);
                        this.clearSpeechTimeout();
                        this.isSpeaking = false;
                        this.currentUtterance = null;
                        reject(new Error(`Speech synthesis failed: ${event.error}`));
                        this.processQueue();
                    };
                    
                    utterance.onstart = () => {
                        this.log('üé§ Speech started');
                    };
                    
                    this.currentUtterance = utterance;
                    this.log('üöÄ Calling speechSynthesis.speak()...');
                    this.speechSynthesis.speak(utterance);
                    
                } catch (error) {
                    this.log(`‚ùå Exception in performSpeech: ${error.message}`);
                    this.clearSpeechTimeout();
                    this.isSpeaking = false;
                    reject(error);
                    this.processQueue();
                }
            }
            
            stopSpeaking() {
                this.log('üõë Stopping speech...');
                this.clearSpeechTimeout();
                
                if (this.speechSynthesis && typeof this.speechSynthesis.cancel === 'function') {
                    this.speechSynthesis.cancel();
                }
                
                this.currentUtterance = null;
                this.isSpeaking = false;
                
                this.speechQueue.forEach(({ reject }) => {
                    reject(new Error('Speech interrupted'));
                });
                this.speechQueue = [];
            }
            
            resetSpeechState() {
                this.log('üîÑ Force resetting speech state...');
                this.clearSpeechTimeout();
                this.isSpeaking = false;
                this.currentUtterance = null;
                this.speechQueue = [];
                
                if (this.speechSynthesis && typeof this.speechSynthesis.cancel === 'function') {
                    this.speechSynthesis.cancel();
                }
            }
            
            clearSpeechTimeout() {
                if (this.speechTimeout) {
                    clearTimeout(this.speechTimeout);
                    this.speechTimeout = null;
                }
            }
            
            forceSpeechReset() {
                this.log('üö® Force resetting stuck speech state');
                this.clearSpeechTimeout();
                this.isSpeaking = false;
                this.currentUtterance = null;
                
                if (this.speechSynthesis && typeof this.speechSynthesis.cancel === 'function') {
                    this.speechSynthesis.cancel();
                }
            }
            
            processQueue() {
                if (this.speechQueue.length === 0 || this.isSpeaking) return;
                
                const { text, options, resolve, reject } = this.speechQueue.shift();
                this.performSpeech(text, options, resolve, reject);
            }
            
            getDebugInfo() {
                return {
                    isInitialized: this.isInitialized,
                    userInteracted: this.userInteracted,
                    voicesLoaded: this.voicesLoaded,
                    speechSynthesisAvailable: !!this.speechSynthesis,
                    currentVoice: this.preferredVoice?.name,
                    isSpeaking: this.isSpeaking,
                    queueLength: this.speechQueue.length,
                    availableVoicesCount: this.availableVoices.length,
                    speechStartTime: this.speechStartTime,
                    timeoutActive: !!this.speechTimeout
                };
            }
            
            log(message) {
                console.log(message);
                const logDiv = document.getElementById('log');
                const timestamp = new Date().toLocaleTimeString();
                logDiv.innerHTML += `[${timestamp}] ${message}\n`;
                logDiv.scrollTop = logDiv.scrollHeight;
            }
        }
        
        // Initialize the test service
        const audioService = new TestAudioService();
        
        // Test functions
        async function initializeAudio() {
            try {
                await audioService.initialize();
                showStatus('Audio initialized successfully', 'success');
            } catch (error) {
                showStatus(`Initialization failed: ${error.message}`, 'error');
            }
        }
        
        function forceResetSpeech() {
            audioService.resetSpeechState();
            showStatus('Speech state reset', 'warning');
        }
        
        async function testShortSpeech() {
            try {
                await audioService.speak('Hello! This is a short test.');
                showStatus('Short speech completed', 'success');
            } catch (error) {
                showStatus(`Short speech failed: ${error.message}`, 'error');
            }
        }
        
        async function testLongSpeech() {
            try {
                const longText = 'Hello! This is LISA testing audio output with a much longer text to see if the timeout mechanism works properly. This text should take several seconds to speak and will help us verify that the speech synthesis is working correctly without getting stuck in the isSpeaking state. The timeout should prevent any hanging issues.';
                await audioService.speak(longText);
                showStatus('Long speech completed', 'success');
            } catch (error) {
                showStatus(`Long speech failed: ${error.message}`, 'error');
            }
        }
        
        function testStopSpeech() {
            audioService.stopSpeaking();
            showStatus('Speech stopped', 'warning');
        }
        
        function showDebugInfo() {
            const debugInfo = audioService.getDebugInfo();
            document.getElementById('debug-info').textContent = JSON.stringify(debugInfo, null, 2);
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }
        
        function showStatus(message, type = 'success') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            setTimeout(() => {
                statusDiv.textContent = '';
                statusDiv.className = 'status';
            }, 5000);
        }
        
        // Auto-initialize and show debug info
        window.addEventListener('load', () => {
            initializeAudio();
            showDebugInfo();
            setInterval(showDebugInfo, 2000); // Update debug info every 2 seconds
        });
    </script>
</body>
</html>
